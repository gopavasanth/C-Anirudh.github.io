<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="en-in"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Notes - The Network Layer" /><meta property="og:locale" content="en" /><meta name="description" content="The following notes have been made with reference to the book Computer Networking A Top Down Approach by Kurose and Ross. Content has been quoted from the book. All credits to the author." /><meta property="og:description" content="The following notes have been made with reference to the book Computer Networking A Top Down Approach by Kurose and Ross. Content has been quoted from the book. All credits to the author." /><link rel="canonical" href="https://c-anirudh.github.io/C-Anirudh.github.io/posts/notes-the-network-layer/" /><meta property="og:url" content="https://c-anirudh.github.io/C-Anirudh.github.io/posts/notes-the-network-layer/" /><meta property="og:site_name" content="Chidambaranathan Anirudh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-06-26T11:41:00+05:30" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Notes - The Network Layer" /><meta name="twitter:site" content="@c_anirudh16" /><meta name="google-site-verification" content="MvB5B93DrVK-3EKC9fBVJKfWOvV_xuirE2Dcbw0qdKE" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-06-26T11:41:00+05:30","datePublished":"2020-06-26T11:41:00+05:30","description":"The following notes have been made with reference to the book Computer Networking A Top Down Approach by Kurose and Ross. Content has been quoted from the book. All credits to the author.","headline":"Notes - The Network Layer","mainEntityOfPage":{"@type":"WebPage","@id":"https://c-anirudh.github.io/C-Anirudh.github.io/posts/notes-the-network-layer/"},"url":"https://c-anirudh.github.io/C-Anirudh.github.io/posts/notes-the-network-layer/"}</script><title>Notes - The Network Layer | Chidambaranathan Anirudh</title><link rel="apple-touch-icon" sizes="180x180" href="/C-Anirudh.github.io/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/C-Anirudh.github.io/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/C-Anirudh.github.io/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/C-Anirudh.github.io/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/C-Anirudh.github.io/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Chidambaranathan Anirudh"><meta name="application-name" content="Chidambaranathan Anirudh"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/C-Anirudh.github.io/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/C-Anirudh.github.io/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/C-Anirudh.github.io/" alt="avatar" class="mx-auto"> <img src=" /C-Anirudh.github.io/assets/img/avatar.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/C-Anirudh.github.io/">Chidambaranathan Anirudh</a></div><div class="site-subtitle font-italic">ASE @Oracle | CS Grad</div></div><ul class="w-100"><li class="nav-item"> <a href="/C-Anirudh.github.io/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/C-Anirudh.github.io/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/C-Anirudh.github.io/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/C-Anirudh.github.io/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/C-Anirudh.github.io/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/C-Anirudh" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/c_anirudh16" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['caniruhd16','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://linkedin.com/in/c-anirudh" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://stackoverflow.com/users/10132227/c-anirudh?tab=profile" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/C-Anirudh.github.io/"> Home </a> </span> <span>Notes - The Network Layer</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Notes - The Network Layer</h1><div class="post-meta text-muted"><div> By <em> <a href="https://www.linkedin.com/in/c-anirudh">Chidambaranathan Anirudh</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1593151860" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-06-26 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4732 words"> <em>26 min</em> read</span></div></div></div><div class="post-content"><blockquote class="prompt-info"><div><p>The following notes have been made with reference to the book <a href="https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html?tab=contents">Computer Networking A Top Down Approach by Kurose and Ross</a>. Content has been quoted from the book. All credits to the author.</p></div></blockquote><ul><li><p>The transport layer provides various forms of process-to-process communication by relying on the network layer’s host-to-host communication service. It does so without any knowledge about how the network layer actually implements this service.</p><li><p>Unlike the transport and application layers, there is a piece of the network layer in each and every host and router in the network.</p><li><p>An important distinction to keep in mind between the <strong>forwarding</strong> and <strong>routing</strong> functions of the network layer.</p><ul><li><strong>Forwarding</strong> involves the transfer of a packet from an incoming link to an outgoing link within a single router.<li><strong>Routing</strong> involves all of a network’s routers, whose collective interactions via routing protocols determine the paths that packets take on their trips from source to destination node.</ul></ul><h2 id="introduction"><span class="mr-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/network-layer.png" alt="The Network Layer" title="The Network Layer" data-proofer-ignore></p><ul><li>Two hosts H1 &amp; H2 and suppose H1 is sending information to H2.<ul><li>The network layer in H1 takes segments from the transport layer in H1, encapsulates each segment into a datagram (that is, a network-layer packet), and then sends the datagrams to its nearby router, R1.<li>At the receiving host, H2, the network layer receives the datagrams from its nearby router R2, extracts the transport-layer segments, and delivers the segments up to the transport layer at H2.<li>The primary role of the routers is to forward datagrams from input links to output links.<li><strong>Note:</strong> The routers in Figure 4.1 are shown with a truncated protocol stack, that is, with no upper layers above the network layer, because (except for control purposes) routers do not run application and transport-layer protocols.</ul></ul><h3 id="forwarding-and-routing"><span class="mr-2">Forwarding and Routing</span><a href="#forwarding-and-routing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>The role of the network layer is thus deceptively simple—to move packets from a sending host to a receiving host. To do so, two important network-layer functions can be identified:<ul><li><em>Forwarding:</em> When a packet arrives at a router’s input link, the router must move the packet to the appropriate output link.<li><em>Routing:</em> The network layer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are referred to as routing algorithms.</ul><li>Every router has a <strong>forwarding table</strong>.<ul><li>A router forwards a packet by examining the value of a field in the arriving packet’s header, and then using this header value to index into the router’s forwarding table.<li>The value stored in the forwarding table entry for that header indicates the router’s outgoing link interface to which that packet is to be forwarded.<li>Depending on the network-layer protocol, the header value could be the destination address of the packet or an indication of the connection to which the packet belongs.</ul></ul><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/forwarding-table.png" alt="Forwarding Table" title="Forwarding Table" data-proofer-ignore></p><ul><li>The routing algorithm determines the values that are inserted into the routers’ forwarding tables.<li>The routing algorithm may be:<ul><li><em>Centralized</em> (e.g., with an algorithm executing on a central site and downloading routing information to each of the routers)<li><em>Decentralized</em> (i.e., with a piece of the distributed routing algorithm running in each router)</ul><li><p>In either case, a router receives routing protocol messages, which are used to configure its forwarding table.</p><li>Some other terms:<ul><li><em>Packet switch:</em> a general packet-switching device that transfers a packet from input link interface to output link interface, according to the value in a field in the header of the packet.<li>Some packet switches, called <strong>link-layer switches</strong>, base their forwarding decision on values in the fields of the link-layer frame; switches are thus referred to as link-layer (layer 2) devices.<li>Other packet switches, called <strong>routers</strong>, base their forwarding decision on the value in the network-layer field. Routers are thus network-layer (layer 3) devices, but must also implement layer 2 protocols as well, since layer 3 devices require the services of layer 2 to implement their (layer 3) functionality.</ul><li>Other than forwarding and routing, in some computer networks there is a third important funtion called <strong>connection setup</strong><ul><li>Some network layer architectures—for example, ATM, frame relay, and MPLS ––require the routers along the chosen path from source to destination to handshake with each other in order to set up state before network-layer data packets within a given source-to-destination connection can begin to flow. In the network layer, this process is referred to as <em>connection setup</em>.</ul></ul><h2 id="virtual-circuit-and-datagram-networks"><span class="mr-2">Virtual Circuit and Datagram Networks</span><a href="#virtual-circuit-and-datagram-networks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Like the transport layer, the network layer can provide connectionless service or connection service between two hosts.<li>A network-layer connection service begins with handshaking between the source and destination hosts; and a network-layer connectionless service does not have any handshaking preliminaries.<li>Although there are parallels with the transport layer connection-oriented and connectionless services, there are crucial differences:<ul><li>In network layer, services are host-to-host services provided by the network layer for the transport layer. In the transport layer the services are process-to-process services provided by the transport layer for the application layer.<li><em>In all major computer network architectures to date (Internet, ATM, frame relay, and so on), the network layer provides either a host-to-host connectionless service or a host-to-host connection service, but not both.</em> Computer networks that provide only a connection service at the network layer are called <strong>virtual-circuit (VC) networks</strong>; computer networks that provide only a connectionless service at the network layer are called <strong>datagram networks</strong>.<li>The implementation of connection-oriented service in the transport layer and connection service in the network layer are different. Transport layer connection-oriented service is implemented at the edge of the network in the end systems; network layer connection service is implemented in the routers in the network core as well as in the end systems.</ul></ul><h3 id="virtual-circuit-networks"><span class="mr-2">Virtual-Circuit Networks</span><a href="#virtual-circuit-networks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>While the Internet is a datagram network, many alternative network architectures including those of ATM and frame relay are virtual-circuit networks and, therefore, use connections at the network layer.<li>These network-layer connections are called <strong>virtual circuits (VCs)</strong>.<li>A VC consists of:<ul><li>a path (that is, a series of links and routers) between the source and destination hosts<li>VC numbers, one number for each link along the path<li>entries in the forwarding table in each router along the path</ul><li>A packet belonging to a virtual circuit will carry a VC number in its header. Because a virtual circuit may have a different VC number on each link, each intervening router must replace the VC number of each traversing packet with a new VC number. The new VC number is obtained from the forwarding table.</ul><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/vc-network.png" alt="A simple virtual circuit network" title="A simple virtual circuit network" data-proofer-ignore></p><ul><li><p>To illustrate the concept, consider the network shown in Figure 4.3. The numbers next to the links of R1 in Figure 4.3 are the link interface numbers. Suppose now that Host A requests that the network establish a VC between itself and Host B. Suppose also that the network chooses the path A-R1-R2-B and assigns VC numbers 12, 22, and 32 to the three links in this path for this virtual circuit. In this case, when a packet in this VC leaves Host A, the value in the VC number field in the packet header is 12; when it leaves R1, the value is 22; and when it leaves R2, the value is 32.</p><li><p>For a VC network, each router’s forwarding table includes VC number translation; for example, the forwarding table in R1 might look something like this:</p></ul><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/vc-routing-table.png" alt="VC routing table" title="VC routing table" data-proofer-ignore></p><ul><li>Why have different VC number for each link along the path?<ul><li>First, replacing the number from link to link reduces the length of the VC field in the packet header.<li>Second, and more importantly, VC setup is considerably simplified by permitting a different VC number at each link along the path of the VC. If a common VC number were required for all links along the path, the routers would have to exchange and process a substantial number of messages to agree on a common VC number (e.g., one that is not being used by any other existing VC at these routers) to be used for a connection.</ul><li><p>In a VC network, the network’s routers must maintain <strong>connection state information</strong> for the ongoing connections. Specifically, each time a new connection is established across a router, a new connection entry must be added to the router’s forwarding table; and each time a connection is released, an entry must be removed from the table.</p><li>There are three identifiable phases in a virtual circuit:<ul><li><strong>VC setup:</strong> During the setup phase, the sending transport layer contacts the network layer, specifies the receiver’s address, and waits for the network to set up the VC. The network layer determines the path between sender and receiver, that is, the series of links and routers through which all packets of the VC will travel. The network layer also determines the VC number for each link along the path. Finally, the network layer adds an entry in the forwarding table in each router along the path. During VC setup, the network layer may also reserve resources (for example, bandwidth) along the path of the VC.<li><strong>Data transfer:</strong> As shown in Figure 4.4, once the VC has been established, packets can begin to flow along the VC.<li><strong>VC teardown:</strong> This is initiated when the sender (or receiver) informs the network layer of its desire to terminate the VC. The network layer will then typically inform the end system on the other side of the network of the call termination and update the forwarding tables in each of the packet routers on the path to indicate that the VC no longer exists.</ul></ul><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/vc-setup.png" alt="VC setup" title="VC setup" data-proofer-ignore></p><ul><li>The messages that the end systems send into the network to initiate or terminate a VC, and the messages passed between the routers to set up the VC (that is, to modify connection state in router tables) are known as <strong>signaling messages</strong>, and the protocols used to exchange these messages are often referred to as <strong>signaling protocols</strong>.</ul><h3 id="datagram-networks"><span class="mr-2">Datagram Networks</span><a href="#datagram-networks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>In a datagram network, each time an end system wants to send a packet, it stamps the packet with the address of the destination end system and then pops the packet into the network.<li>As a packet is transmitted from source to destination, it passes through a series of routers. Each of these routers uses the packet’s destination address to forward the packet.<li>Specifically, each router has a forwarding table that maps destination addresses to link interfaces; when a packet arrives at the router, the router uses the packet’s destination address to look up the appropriate output link interface in the forwarding table. The router then intentionally forwards the packet to that output link interface.</ul><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/datagram-network.png" alt="Datagram network" title="Datagram network" data-proofer-ignore></p><ul><li>To get some further insight into the lookup operation, let’s look at a specific example.<ul><li>Suppose that all destination addresses are 32 bits.<li>A brute-force implementation of the forwarding table would have one entry for every possible destination address. Since there are more than 4 billion possible addresses, this option is totally out of the question.<li>Now let’s further suppose that our router has four links, numbered 0 through 3, and that packets are to be forwarded to the link interfaces as follows: <img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/datagram-forwarding.png" alt="Datagram network forwarding" title="Datagram network forwarding" data-proofer-ignore><li>We could, for example, have the following forwarding table with just four entries: <img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/datagram-forwarding-table.png" alt="Datagram network forwarding table" title="Datagram network forwarding table" data-proofer-ignore><li>With this style of forwarding table, the router matches a <strong>prefix</strong> of the packet’s destination address with the entries in the table; if there’s a match, the router forwards the packet to a link associated with the match.<li>When there are multiple matches, the router uses the longest prefix matching rule; that is, it finds the longest matching entry in the table and forwards the packet to the link interface associated with the longest prefix match.</ul></ul><h2 id="whats-inside-a-router"><span class="mr-2">What’s inside a Router?</span><a href="#whats-inside-a-router" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/router-architecture.png" alt="Router architecture" title="Router architecture" data-proofer-ignore></p><ul><li>A high-level view of a generic router architecture is shown in Figure 4.6. Four router components can be identified:<ul><li><strong>Input ports:</strong><ul><li>An input port performs several key functions.<ul><li>It performs the physical layer function of terminating an incoming physical link at a router<li>An input port also performs link-layer functions needed to interoperate with the link layer at the other side of the incoming link<li>Perhaps most crucially, the lookup function is also performed at the input port. It is here that the forwarding table is consulted to determine the router output port to which an arriving packet will be forwarded via the switching fabric.</ul><li>Control packets (for example, packets carrying routing protocol information) are forwarded from an input port to the routing processor.<li><strong>Note</strong> that the term port here refers to the physical input and output router interfaces</ul><li><strong>Switching fabric</strong><ul><li>The switching fabric connects the router’s input ports to its output ports. This switching fabric is completely contained within the router—a network inside of a network router!</ul><li><strong>Output ports</strong><ul><li>An output port stores packets received from the switching fabric and transmits these packets on the outgoing link by performing the necessary link-layer and physical-layer functions.</ul><li><strong>Routing processor</strong><ul><li>The routing processor executes the routing protocols, maintains routing tables and attached link state information, and computes the forwarding table for the router. It also performs some network management functions.</ul></ul><li>A router’s input ports, output ports, and switching fabric together implement the forwarding function and are almost always implemented in hardware. These forwarding functions are sometimes collectively referred to as the <strong>router forwarding plane</strong>.<li>The <strong>router control plane</strong> functions are usually implemented in software and execute on the routing processor (typically a traditional CPU).</ul><h3 id="input-processing"><span class="mr-2">Input Processing</span><a href="#input-processing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/input-port-processing.png" alt="Input port processing" title="Input port processing" data-proofer-ignore></p><ul><li>A more detailed view of input processing is given in Figure 4.7.<li>As discussed above, the input port’s line termination function and link-layer processing implement the physical and link layers for that individual input link.<li>The lookup performed in the input port is central to the router’s operation—it is here that the router uses the forwarding table to look up the output port to which an arriving packet will be forwarded via the switching fabric.<li>The forwarding table is computed and updated by the routing processor, with a shadow copy typically stored at each input port. The forwarding table is copied from the routing processor to the line cards over a separate bus (e.g., a PCI bus) indicated by the dashed line from the routing processor to the input line cards in Figure 4.6.<li>With a shadow copy, forwarding decisions can be made locally, at each input port, without invoking the centralized routing processor on a per-packet basis and thus avoiding a centralized processing bottleneck.<li>Given the existence of a forwarding table, lookup is conceptually simple—we just search through the forwarding table looking for the longest prefix match, lookup must be performed in hardware for speed.<li>Once a packet’s output port has been determined via the lookup, the packet can be sent into the switching fabric. In some designs, a packet may be temporarily blocked from entering the switching fabric if packets from other input ports are currently using the fabric. A blocked packet will be queued at the input port and then scheduled to cross the fabric at a later point in time.<li>Although “lookup” is arguably the most important action in input port processing, many other actions must be taken:<ul><li>physical and link-layer processing must occur, as discussed above<li>the packet’s version number, checksum and time-to-live field must be checked and the latter two fields rewritten<li>counters used for network management (such as the number of IP datagrams received) must be updated.</ul></ul><h3 id="output-processing"><span class="mr-2">Output processing</span><a href="#output-processing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/output-port-processing.png" alt="Output port processing" title="Output port processing" data-proofer-ignore></p><ul><li>Output port processing, shown in Figure 4.9, takes packets that have been stored in the output port’s memory and transmits them over the output link. This includes selecting and de-queueing packets for transmission, and performing the needed link-layer and physical-layer transmission functions.</ul><h3 id="what-is-head-of-the-line-hol-blocking"><span class="mr-2">What is Head-of-the-Line (HOL) blocking</span><a href="#what-is-head-of-the-line-hol-blocking" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/HOL-blocking.png" alt="HOL blocking og input queued switch" title="HOL blocking og input queued switch" data-proofer-ignore></p><ul><li>Figure 4.11 shows an example in which two packets (darkly shaded) at the front of their input queues are destined for the same upper-right output port. Suppose that the switch fabric chooses to transfer the packet from the front of the upper-left queue. In this case, the darkly shaded packet in the lower-left queue must wait. But not only must this darkly shaded packet wait, so too must the lightly shaded packet that is queued behind that packet in the lower-left queue, even though there is no contention for the middle-right output port (the destination for the lightly shaded packet). This phenomenon is known as <strong>head-of-the-line (HOL) blocking</strong> in an input-queued switch.</ul><h2 id="reference-videos-for-some-topics"><span class="mr-2">Reference videos for some topics</span><a href="#reference-videos-for-some-topics" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><div class="table-wrapper"><table><thead><tr><th>Topic<th>Video Link<tbody><tr><td>IP Datagram Format<td><a href="https://www.youtube.com/watch?v=AffMzrz96Nc">https://www.youtube.com/watch?v=AffMzrz96Nc</a><tr><td>IP Data Fragmentation and Re-Assembly<td><a href="https://www.youtube.com/watch?v=MmJonsmiwqc">https://www.youtube.com/watch?v=MmJonsmiwqc</a><tr><td>Introduction to Computer network and IP address<td><a href="https://www.youtube.com/watch?v=UXMIxCYZu8o">https://www.youtube.com/watch?v=UXMIxCYZu8o</a><tr><td>Types of Casting: Unicast, Limited Broadcast, Directed Broadcast<td><a href="https://www.youtube.com/watch?v=hffYt7RDrgk&amp;t=630s">https://www.youtube.com/watch?v=hffYt7RDrgk&amp;t=630s</a><tr><td>Subnets, Subnet Mask, Routing<td><a href="https://www.youtube.com/watch?v=3QWrq5gN8VY&amp;t=209s">https://www.youtube.com/watch?v=3QWrq5gN8VY&amp;t=209s</a><tr><td>Variable length subnet masking (VLSM)<td><a href="https://www.youtube.com/watch?v=GJrS5ckgjAs&amp;t=622s">https://www.youtube.com/watch?v=GJrS5ckgjAs&amp;t=622s</a><tr><td>Classless Inter Domain Routing (CIDR)<td><a href="https://www.youtube.com/watch?v=86RDE_bP1Bs&amp;pbjreload=10">https://www.youtube.com/watch?v=86RDE_bP1Bs&amp;pbjreload=10</a><tr><td>Subnetting in CIDR, VLSM in CIDR<td><a href="https://www.youtube.com/watch?v=zYOgpo0SDBc&amp;pbjreload=10">https://www.youtube.com/watch?v=zYOgpo0SDBc&amp;pbjreload=10</a><tr><td>Some interesting problems on subnet mask<td><a href="https://www.youtube.com/watch?v=O-8MYVVKpk8">https://www.youtube.com/watch?v=O-8MYVVKpk8</a></table></div><h2 id="obtaining-a-host-address-the-dynamic-host-configuration-protocol-dhcp"><span class="mr-2">Obtaining a Host Address: the Dynamic Host Configuration Protocol (DHCP)</span><a href="#obtaining-a-host-address-the-dynamic-host-configuration-protocol-dhcp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Once an organization has obtained a block of addresses, it can assign individual IP addresses to the host and router interfaces in its organization. A system administrator will typically manually configure the IP addresses into the router (often remotely, with a network management tool). Host addresses can also be configured manually, but more often this task is now done using the <strong>Dynamic Host Configuration Protocol (DHCP)</strong>.<li>DHCP allows a host to obtain (be allocated) an IP address automatically. A network administrator can configure DHCP so that a given host receives the same IP address each time it connects to the network, or a host may be assigned a temporary IP address that will be different each time the host connects to the network.<li>In addition to host IP address assignment, DHCP also allows a host to learn additional information, such as its subnet mask, the address of its first-hop router (often called the default gateway), and the address of its local DNS server.<li>Because of DHCP’s ability to automate the network-related aspects of connecting a host into a network, it is often referred to as a <strong>plug-and-play protocol</strong>.<li>DHCP is a client-server protocol. A client is typically a newly arriving host wanting to obtain network configuration information, including an IP address for itself.<li>In the simplest case, each subnet will have a DHCP server. If no server is present on the subnet, a DHCP relay agent (typically a router) that knows the address of a DHCP server for that network is needed. Figure 4.20 shows a DHCP server attached to subnet 223.1.2/24, with the router serving as the relay agent for arriving clients attached to subnets 223.1.1/24 and 223.1.3/24. In our discussion below, we’ll assume that a DHCP server is available on the subnet.</ul><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/DHCP-client-server-scenario.png" alt="DHCP client-server-scenario" title="DHCP client-server-scenario" data-proofer-ignore></p><ul><li>For a newly arriving host, the DHCP protocol is a four-step process. The four steps are:<ul><li><strong>DHCP server discovery</strong><ul><li>The first task of a newly arriving host is to find a DHCP server with which to interact. This is done using a <strong>DHCP discover message</strong>, which a client sends within a UDP packet to port 67. The UDP packet is encapsulated in an IP datagram.<li>But to whom should this datagram be sent? The host doesn’t even know the IP address of the network to which it is attaching, much less the address of a DHCP server for this network.<li>Given this, the DHCP client creates an IP datagram containing its DHCP discover message along with the broadcast destination IP address of 255.255.255.255 and a “this host” source IP address of 0.0.0.0. The DHCP client passes the IP datagram to the link layer, which then broadcasts this frame to all nodes attached to the subnet.</ul><p>An interesting read about the <code class="language-plaintext highlighter-rouge">0.0.0.0</code> IP address =&gt; <a href="https://superuser.com/questions/949428/whats-the-difference-between-127-0-0-1-and-0-0-0-0">https://superuser.com/questions/949428/whats-the-difference-between-127-0-0-1-and-0-0-0-0</a></p><li><strong>DHCP server offer(s)</strong><ul><li>A DHCP server receiving a DHCP discover message responds to the client with a <strong>DHCP offer message</strong> that is broadcast to all nodes on the subnet, again using the IP broadcast address of 255.255.255.255.<li>Since several DHCP servers can be present on the subnet, the client may find itself in the enviable position of being able to choose from among several offers. Each server offer message contains the transaction ID of the received discover message, the proposed IP address for the client, the network mask, and an <strong>IP address lease time</strong>—the amount of time for which the IP address will be valid. It is common for the server to set the lease time to several hours or days.</ul><li><strong>DHCP request</strong><ul><li>The newly arriving client will choose from among one or more transmitsserver offers and respond to its selected offer with a <strong>DHCP request message</strong>, echoing back the configuration parameters.</ul><li><strong>DHCP ACK</strong><ul><li>The server responds to the DHCP request message with a <strong>DHCP ACK message</strong>, confirming the requested parameters.</ul></ul></ul><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/DHCP-client-server-interaction.png" alt="DHCP client-server interaction" title="DHCP client-server interaction" data-proofer-ignore></p><ul><li><p>Once the client receives the DHCP ACK, the interaction is complete and the client can use the DHCP-allocated IP address for the lease duration. Since a client may want to use its address beyond the lease’s expiration, DHCP also provides a mechanism that allows a client to renew its lease on an IP address.</p><li><p>From a mobility aspect, however, DHCP does have shortcomings. Since a new IP address is obtained from DHCP each time a node connects to a new subnet, a TCP connection to a remote application cannot be maintained as a mobile node moves between subnets.</p></ul><h2 id="network-address-translation-nat"><span class="mr-2">Network Address Translation (NAT)</span><a href="#network-address-translation-nat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Reference video - <a href="https://youtu.be/_MZbwHyE0Ck">https://youtu.be/_MZbwHyE0Ck</a></p><h2 id="routing-algorithms"><span class="mr-2">Routing Algorithms</span><a href="#routing-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>Whether the network layer provides a datagram service (in which case different packets between a given source-destination pair may take different routes) or a VC service (in which case all packets between a given source and destination will take the same path), the network layer must nonetheless determine the path that packets take from senders to receivers. We’ll see that the job of routing is to determine good paths (equivalently, routes), from senders to receivers, through the network of routers.</p><li><p>Typically a host is attached directly to one router, the <strong>default router</strong> for the host (also called the <strong>first-hop router</strong> for the host). Whenever a host sends a packet, the packet is transferred to its default router. We refer to the default router of the source host as the <strong>source router</strong> and the default router of the destination host as the <strong>destination router</strong>. The problem of routing a packet from source host to destination host clearly boils down to the problem of routing the packet from source router to destination router.</p></ul><p><img data-src="/C-Anirudh.github.io/assets/img/posts/network-layer/abstract-graph-model-cn.png" alt="Abstract graph model of computer network" title="Abstract graph model of computer network" data-proofer-ignore></p><ul><li><p>A graph is used to formulate routing problems. Recall that a graph G = (N,E) is a set N of nodes and a collection E of edges, where each edge is a pair of nodes from N. In the context of network-layer routing, the nodes in the graph represent routers—the points at which packet-forwarding decisions are made—and the edges connecting these nodes represent the physical links between these routers. Such a graph abstraction of a computer network is shown in Figure 4.27.</p><li><p>An edge also has a value representing its cost. Typically, an edge’s cost may reflect the physical length of the corresponding link, the link speed, or the monetary cost associated with a link.</p><li>Broadly, one way in which we can classify routing algorithms is according to whether they are global or decentralized.<ul><li><p>A <strong>global routing algorithm</strong> computes the least-cost path between a source and destination using complete, global knowledge about the network. That is, the algorithm takes the connectivity between all nodes and all link costs as inputs. This then requires that the algorithm somehow obtain this information before actually performing the calculation. The calculation itself can be run at one site (a centralized global routing algorithm) or replicated at multiple sites. In practice, algorithms with global state information are often referred to as <strong>link-state (LS) algorithms</strong>, since the algorithm must be aware of the cost of each link in the network.</p><li><p>In a <strong>decentralized routing algorithm</strong>, the calculation of the least-cost path is carried out in an iterative, distributed manner. No node has complete information about the costs of all network links. Instead, each node begins with only the knowledge of the costs of its own directly attached links. Then, through an iterative process of calculation and exchange of information with its neighboring nodes (that is, nodes that are at the other end of links to which it itself is attached), a node gradually calculates the least-cost path to a destination or set of destinations. The decentralized routing algorithm we will see is called a <strong>distance-vector (DV) algorithm</strong>, because each node maintains a vector of estimates of the costs (distances) to all other nodes in the network.</p></ul><li>A second broad way to classify routing algorithms is according to whether they are static or dynamic.<ul><li><p>In <strong>static routing algorithms</strong>, routes change very slowly over time, often as a result of human intervention (for example, a human manually editing a router’s forwarding table).</p><li><p><strong>Dynamic routing algorithms</strong> change the routing paths as the network traffic loads or topology change. A dynamic algorithm can be run either periodically or in direct response to topology or link cost changes. While dynamic algorithms are more responsive to network changes, they are also more susceptible to problems such as routing loops and oscillation in routes.</p></ul><li>A third way to classify routing algorithms is according to whether they are load-sensitive or load-insensitive.<ul><li><p>In a <strong>load-sensitive algorithm</strong>, link costs vary dynamically to reflect the current level of congestion in the underlying link. If a high cost is associated with a link that is currently congested, a routing algorithm will tend to choose routes around such a congested link.</p><li><p>Today’s Internet routing algorithms (such as RIP, OSPF, and BGP) are <strong>load-insensitive</strong>, as a link’s cost does not explicitly reflect its current (or recent past) level of congestion.</p></ul></ul><h3 id="the-link-state-ls-routing-algorithm"><span class="mr-2">The Link-State (LS) Routing Algorithm</span><a href="#the-link-state-ls-routing-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Recall that in a link-state algorithm, the network topology and all link costs are known, that is, available as input to the LS algorithm. In practice this is accomplished by having each node broadcast link-state packets to all other nodes in the network, with each link-state packet containing the identities and costs of its attached links. In practice this is often accomplished by a <strong>link-state broadcast algorithm</strong>.<li>The link-state routing algorithm we present below is known as <strong>Dijkstra’s algorithm</strong>, named after its inventor.<li>Dijkstra’s algorithm computes the least-cost path from one node to all other nodes in the network.</ul><h3 id="the-distance-vector-dv-routing-algorithm"><span class="mr-2">The Distance-Vector (DV) Routing Algorithm</span><a href="#the-distance-vector-dv-routing-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Whereas the LS algorithm is an algorithm using global information, the distance-vector (DV) algorithm is iterative, asynchronous, and distributed.<li>It is <em>distributed</em> in that each node receives some information from one or more of its directly attached neighbors, performs a calculation, and then distributes the results of its calculation back to its neighbors.<li>It is <em>iterative</em> in that this process continues on until no more information is exchanged between neighbors (Interestingly, the algorithm is also self-terminating—there is no signal that the computation should stop; it just stops).<li>The algorithm is <em>asynchronous</em> in that it does not require all of the nodes to operate in lockstep with each other.<li><strong>Bellman-Ford</strong> is used to calculate the distances between the nodes.<li>DV-like algorithms are used in many routing protocols in practice, including the Internet’s RIP and BGP, ISO IDRP, Novell IPX, and the original ARPAnet.</ul><h3 id="a-comparison-of-ls-and-dv-routing-algorithms"><span class="mr-2">A Comparison of LS and DV Routing Algorithms</span><a href="#a-comparison-of-ls-and-dv-routing-algorithms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="table-wrapper"><table><thead><tr><th>LS Routing Algorithm<th>DV Routing Algorithm<tbody><tr><td>Each node talks with all other nodes (via broadcast), but it tells them only the costs of its directly connected links.<td>Each node talks to only its directly connected neighbors, but it provides its neighbors with least-cost estimates from itself to all the nodes (that it knows about) in the network.<tr><td>Each node requires to know the cost of each link in the network. This requires O(N.E) messages to be sent. Also, whenever a link cost changes, the new link cost must be sent to all nodes.<td>The DV algorithm requires message exchanges between directly connected neighbors at each iteration. The time needed for the algorithm to converge can depend on many factors. When link costs change, the DV algorithm will propagate the results of the changed link cost only if the new link cost results in a changed least-cost path for one of the nodes attached to that link.<tr><td>The implementation of LS is an O(N^2) algorithm requiring O(N.E)) messages.<td>The DV algorithm can converge slowly and can have routing loops while the algorithm is converging. DV also suffers from the count-to-infinity problem.<tr><td>An LS node is computing only its own forwarding tables; other nodes are performing similar calculations for themselves. This means route calculations are somewhat separated under LS, providing a degree of robustness.<td>An incorrect node calculation can be diffused through the entire network under DV.</table></div><p>In the end, neither algorithm is an obvious winner over the other; indeed, both algorithms are used in the Internet.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/C-Anirudh.github.io/categories/academic-notes/'>Academic Notes</a>, <a href='/C-Anirudh.github.io/categories/computer-networks/'>Computer Networks</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/C-Anirudh.github.io/tags/ip/" class="post-tag no-text-decoration" >ip</a> <a href="/C-Anirudh.github.io/tags/notes/" class="post-tag no-text-decoration" >notes</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Notes - The Network Layer - Chidambaranathan Anirudh&amp;url=https://c-anirudh.github.io/C-Anirudh.github.io/posts/notes-the-network-layer/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Notes - The Network Layer - Chidambaranathan Anirudh&amp;u=https://c-anirudh.github.io/C-Anirudh.github.io/posts/notes-the-network-layer/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://c-anirudh.github.io/C-Anirudh.github.io/posts/notes-the-network-layer/&amp;text=Notes - The Network Layer - Chidambaranathan Anirudh" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://c-anirudh.github.io/C-Anirudh.github.io/posts/notes-the-network-layer/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/C-Anirudh.github.io/tags/notes/">notes</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/ctf/">ctf</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/writeups/">writeups</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/aptitude/">aptitude</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/calendar/">calendar</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/cetus-extension/">cetus-extension</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/email-security/">email-security</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/experience/">experience</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/git-security/">git-security</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/go/">go</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/C-Anirudh.github.io/posts/notes-tcp-congestion-control/"><div class="card-body"> <em class="timeago small" data-ts="1593670260" > 2020-07-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Notes - TCP Congestion Control</h3><div class="text-muted small"><p> The following notes have been made with reference to the book Computer Networking A Top Down Approach by Kurose and Ross. Content has been quoted from the book. All credits to the author. T...</p></div></div></a></div><div class="card"> <a href="/C-Anirudh.github.io/posts/notes-pretty-good-privacy/"><div class="card-body"> <em class="timeago small" data-ts="1593073200" > 2020-06-25 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Notes - Pretty Good Privacy (PGP)</h3><div class="text-muted small"><p> The following notes have been made with reference to the book Cryptography and Network Security: Principles and Practice, 5th Edition by William Stallings. Content has been quoted from the book....</p></div></div></a></div><div class="card"> <a href="/C-Anirudh.github.io/posts/aptitude-topic-calendars/"><div class="card-body"> <em class="timeago small" data-ts="1565194260" > 2019-08-07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Aptitude Topic - Calendars</h3><div class="text-muted small"><p> Years can be classified into two types, a leap year and a non-leap year. A leap year has 366 days while a non-leap year has 365 days. For an year to be a leap year, it must be divisible by 4 but f...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/C-Anirudh.github.io/posts/notes-pretty-good-privacy/" class="btn btn-outline-primary" prompt="Older"><p>Notes - Pretty Good Privacy (PGP)</p></a> <a href="/C-Anirudh.github.io/posts/notes-tcp-congestion-control/" class="btn btn-outline-primary" prompt="Newer"><p>Notes - TCP Congestion Control</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://www.linkedin.com/in/c-anirudh">Chidambaranathan Anirudh</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/C-Anirudh.github.io/tags/notes/">notes</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/ctf/">ctf</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/writeups/">writeups</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/aptitude/">aptitude</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/calendar/">calendar</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/cetus-extension/">cetus-extension</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/email-security/">email-security</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/experience/">experience</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/git-security/">git-security</a> <a class="post-tag" href="/C-Anirudh.github.io/tags/go/">go</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/C-Anirudh.github.io/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en-in.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/C-Anirudh.github.io/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/C-Anirudh.github.io/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-167413140-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-167413140-1'); }); </script>
